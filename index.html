<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Driving Game — Hellcat</title>
  <style>
    html,body{height:100%;margin:0;background:#111;color:#eee;font-family:Inter,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial}
    #container{width:100%;height:100%;overflow:hidden;display:block}
    #ui{position:fixed;left:12px;top:12px;z-index:5;backdrop-filter:blur(6px);padding:8px 12px;border-radius:8px;background:rgba(0,0,0,0.35);box-shadow:0 6px 24px rgba(0,0,0,0.5)}
    #instructions{position:fixed;right:12px;bottom:12px;z-index:5;background:rgba(0,0,0,0.25);padding:8px 12px;border-radius:8px}
    .btn{appearance:none;border:0;background:#2b2b2b;color:#fff;padding:6px 10px;border-radius:6px;cursor:pointer}
  </style>
</head>
<body>
  <div id="container"></div>
  <div id="ui">
    <div style="font-weight:700">3D Driving — Hellcat</div>
    <div id="speed">Speed: 0 km/h</div>
    <div id="lap" style="opacity:.8;font-size:13px">Position: free roam</div>
    <div style="margin-top:8px"><button id="reset" class="btn">Reset</button></div>
  </div>
  <div id="instructions">
    <div><strong>Controls</strong></div>
    <div>W / ↑ : accelerate</div>
    <div>S / ↓ : brake/reverse</div>
    <div>A / ← : steer left</div>
    <div>D / → : steer right</div>
    <div>Space : handbrake</div>
  </div>

  <!-- This version uses Three.js as an ES module and loads a glTF car model named assets/hellcat.glb -->
  <!-- Place your model at /assets/hellcat.glb in the repo. If you want me to add a model, upload it to the canvas or tell me where to fetch it. -->

  <script type="module">
  import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
  import { GLTFLoader } from 'https://unpkg.com/three@0.152.2/examples/jsm/loaders/GLTFLoader.js';

  const container = document.getElementById('container');
  const speedEl = document.getElementById('speed');
  const resetBtn = document.getElementById('reset');

  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.outputEncoding = THREE.sRGBEncoding;
  container.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
  camera.position.set(0,5,-12);
  camera.lookAt(0,0,0);

  const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
  hemi.position.set(0,50,0);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.6);
  dir.position.set(5,10,2);
  scene.add(dir);

  const groundGeo = new THREE.PlaneGeometry(200,200);
  const groundMat = new THREE.MeshStandardMaterial({color:0x2b7a2b,roughness:0.9});
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.receiveShadow = true;
  scene.add(ground);

  // simple road
  const road = new THREE.Group();
  const roadMat = new THREE.MeshStandardMaterial({color:0x333333,metalness:0.1,roughness:0.9});
  for(let i=0;i<40;i++){
    const seg = new THREE.Mesh(new THREE.BoxGeometry(6,0.05,6), roadMat);
    seg.position.set(Math.sin(i*0.2)*20, 0.01, i*4 - 60);
    seg.rotation.y = Math.sin(i*0.2)*0.25;
    road.add(seg);
  }
  scene.add(road);

  // placeholder car group; will be replaced by GLTF model when loaded
  const car = new THREE.Group();
  const body = new THREE.Mesh(new THREE.BoxGeometry(1.8,0.6,4), new THREE.MeshStandardMaterial({color:0xff3333,metalness:0.2,roughness:0.6}));
  body.position.y = 0.6;
  car.add(body);
  car.position.set(0,0,0);
  scene.add(car);

  // Try to load assets/hellcat.glb
  const loader = new GLTFLoader();
  loader.load('/assets/hellcat.glb', (gltf)=>{
    // remove placeholder body
    car.clear();
    const model = gltf.scene || gltf.scenes[0];
    model.traverse((c)=>{ if(c.isMesh){ c.castShadow = true; c.receiveShadow = true; } });
    // scale & center model if necessary
    const box = new THREE.Box3().setFromObject(model);
    const size = new THREE.Vector3(); box.getSize(size);
    const maxDim = Math.max(size.x, size.y, size.z);
    const scale = 3.5 / maxDim; // tune if model is big/small
    model.scale.setScalar(scale);
    // adjust model origin so wheels sit near y=0
    box.setFromObject(model);
    const center = new THREE.Vector3(); box.getCenter(center);
    model.position.sub(center);
    // nudge up
    model.position.y += 0.35;

    car.add(model);
    console.log('Hellcat model loaded');
  }, undefined, (err)=>{
    console.warn('Could not load /assets/hellcat.glb — make sure the file exists in the repo at /assets/hellcat.glb', err);
  });

  // obstacles
  const boxMat = new THREE.MeshStandardMaterial({color:0x8b5a2b});
  for(let i=0;i<10;i++){
    const b = new THREE.Mesh(new THREE.BoxGeometry(2,2,2), boxMat);
    b.position.set((Math.random()-0.5)*60,1,(Math.random()*120)-60);
    scene.add(b);
  }

  const state = {
    speed:0,
    maxSpeed:40,
    accel:30,
    brake:60,
    friction:8,
    steerAngle:0,
    maxSteer:Math.PI/6,
    steerSpeed:2.5,
    velocity: new THREE.Vector3(0,0,0)
  };
  const keys = {forward:false,back:false,left:false,right:false,brake:false};

  function updateControls(dt){
    const forwardInput = keys.forward ? 1:0;
    const backInput = keys.back ? 1:0;
    if(forwardInput){ state.speed += state.accel * dt; }
    if(backInput){ state.speed -= state.brake * dt; }
    if(!forwardInput && !backInput){ if(state.speed>0){ state.speed -= state.friction * dt; if(state.speed<0) state.speed=0; } else if(state.speed<0){ state.speed += state.friction * dt; if(state.speed>0) state.speed=0; } }
    if(state.speed>state.maxSpeed) state.speed = state.maxSpeed;
    if(state.speed < -state.maxSpeed*0.4) state.speed = -state.maxSpeed*0.4;
    const leftInput = keys.left ? 1:0;
    const rightInput = keys.right ? 1:0;
    const steerTarget = (rightInput - leftInput) * state.maxSteer * (1 - Math.abs(state.speed)/state.maxSpeed);
    state.steerAngle += (steerTarget - state.steerAngle) * Math.min(1, state.steerSpeed * dt);
    const turningRadiusFactor = 0.02;
    car.rotation.y += state.speed * state.steerAngle * turningRadiusFactor * dt;
    const forward = new THREE.Vector3(0,0,1).applyAxisAngle(new THREE.Vector3(0,1,0), car.rotation.y).normalize();
    car.position.addScaledVector(forward, -state.speed * dt);
    body.rotation.z = -state.steerAngle * 0.25;
    const camOffset = new THREE.Vector3(0,4,-9).applyAxisAngle(new THREE.Vector3(0,1,0), car.rotation.y);
    const desiredCamPos = new THREE.Vector3().copy(car.position).add(camOffset);
    camera.position.lerp(desiredCamPos, Math.min(1, 5 * dt));
    const lookAt = new THREE.Vector3(
